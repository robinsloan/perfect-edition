<!DOCTYPE html>
<html lang="en">
<!--

Don't worry, spiders,
I keep house
casually.

Kobayashi Issa

-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, height=device-height, initial-scale=1.0, minimum-scale=1.0, user-scalable=0.0" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

  <meta property="og:title" content="{{ title }}" />
  <meta property="og:site_name" content="{{ title }} by {{ author }}" />
  <meta property="og:type" content="book" />
  <meta property="og:book:author" content="{{ author }}" />
  <meta property="og:image" content="{{ home_url }}{{ cover_image }}" />
  <meta property="og:description" content="{{ description }}" />
  <meta property="og:url" content="{{ home_url }}" />

  {% if use_twitter_card %}
  <meta name="twitter:card" content="summary" />
  <meta name="twitter:site" content="{{ twitter_username }}" />
  <meta name="twitter:title" content="{{ title }} by {{ author }}" />
  <meta name="twitter:description" content="{{ description }}" />
  <meta name="twitter:image" content="{{ home_url }}{{ cover_image }}" />
  {% endif %}

  <script type="application/ld+json">
      {
          "@context": "http://schema.org",
          "@type": "Book",
          "name": "{{ title }}",
          "author": "{{ author }}",
          "description": "{{ description }}",
          "url": "{{ home_url }}"
      }
  </script>

  <meta name="generator" content="These human fingers" />

  <link href="css/web-book-{{ guid }}.css" type="text/css" rel="stylesheet" />

  <title>{{ title }}</title>
  <script type="text/javascript">

  // https://github.com/iamdustan/smoothscroll/blob/master/src/smoothscroll.js

  function smoothScroll(x, shouldTurnSlow) {
    const startTime = performance.now();
    const startX = document.body.scrollLeft;

    // scroll
    smoothScrollStep({
      startTime: startTime,
      startX: startX || 0,
      x: x || 0,
      shouldTurnSlow: shouldTurnSlow
    });
  }

  function ease(k) {
    return (-Math.pow(2, -10 * k) + 1);
  }

  const SCROLL_TIME_FAST = 200; // millis
  const SCROLL_TIME_SLOW = 1000; // millis

  function smoothScrollStep(status) {
    const scrollTime = status.shouldTurnSlow ? SCROLL_TIME_SLOW : SCROLL_TIME_FAST;
    let elapsedTime = (performance.now() - status.startTime) / scrollTime;

    // avoid elapsed times higher than one
    elapsedTime = elapsedTime > 1 ? 1 : elapsedTime;

    // apply easing to elapsed time
    const easedValue = ease(elapsedTime);

    const currentX = status.startX + (status.x - status.startX) * easedValue;

    document.body.scrollLeft = currentX;

    // keep scrolling if we have not reached our destination
    // this was > 1.0 and that wasn't working for some reason
    if (Math.abs(currentX - status.x) > 2.0) {
      requestAnimationFrame(smoothScrollStep.bind(window, status));
    }
  }

  function getComputed(propertyName) {
    return Number(
      getComputedStyle(bookElement)
        .getPropertyValue(propertyName)
        .replace("px", ""),
    );
  }

  function getRect(element) {
    // terrible hack for Firefox, which treats getBoundingClientRect as an
    // inner dimension for some unknown reason:
    const rects = element.getClientRects();
    return rects[rects.length - 1];
  }

  function turnPageForward() {
    turnPage(1, false);
  }

  function turnPageBack() {
    turnPage(-1, false);
  }

  function snapToPage() {
    turnPage(0, true);
  }

  function turnPage(turnDirection, shouldTurnSlow) {
    const currentLeftOffset = document.body.scrollLeft;
    const columnWidth = getComputed("column-width");
    const columnGap = getComputed("column-gap");
    const columnTotal = columnWidth + columnGap;

    // this was previously Math.floor which was causing problems when
    // paging backwards
    const closestPageNumber = Math.round(currentLeftOffset / columnTotal) +
      turnDirection;

    writePageNumber(closestPageNumber);

    let closestPageEdge = closestPageNumber * columnTotal;

    // aha, but what if we are already AT that page?
    // 8.0 pixels is a bit of a "magic number"...
    if (Math.abs(closestPageEdge - currentLeftOffset) < 8.0) {
      closestPageEdge += columnTotal * turnDirection;
      writePageNumber(closestPageNumber + 1); // hacky
    }

    // you can't turn the page if you're at the end
    if (
      (turnDirection > 0) &&
      (getRect(endElement).x <= (window.innerWidth + columnGap))
    ) {
      console.log("thud");
      return;
    }

    // if we're turning a page, we are navigating away from a chapter title,
    // so we want to clear this out
    window.location.hash = "";

    smoothScroll(closestPageEdge, shouldTurnSlow);
  }

  function turnToPage(pageNumber) {
    const columnWidth = getComputed("column-width");
    const columnGap = getComputed("column-gap");
    const columnTotal = columnWidth + columnGap;

    const pageEdge = pageNumber * columnTotal;
    if (pageEdge > bookElement.scrollWidth) {
      // Page number is greater than total number of pages currently displayed
      // (this isn't uncommon, because of reflow for different window sizes)
      // so, let's just go the end. Not a perfect solution, fine for now
      pageEdge = bookElement.scrollWidth - (columnTotal + columnWidth);
    }

    // the cute tiny bookmark
    let bookmarkElement = document.querySelector("div.bookmark");
    bookmarkElement.style.display = "block";
    bookmarkElement.style.left = `${pageEdge + columnWidth / 2.0}px`;

    document.body.scrollLeft = pageEdge;
  }

  function turnToAnchor(anchor) {
    const editedAnchor = "chapter_" + anchor.replace("#", "");

    let anchoredHeading = Array.from(document.querySelectorAll("h2"))
      .find((heading) => {
        return heading.getAttribute("id") == editedAnchor;
      });

    anchoredHeading.scrollIntoView();

    const wherePageEdgeShouldBe =
      (window.innerWidth - getRect(bookElement).width) / 2.0;
    const offset = getRect(anchoredHeading).x - wherePageEdgeShouldBe;

    document.body.scrollLeft += offset;
  }

  function setTextScale(scale) {
    document.documentElement.style.setProperty(
      "--font-size",
      `${baseFontSize * scale}px`,
    );
  }

  function toggleNav() {
    if (navElement.className == "invisible") {
      navElement.className = "visible";
    } else {
      navElement.className = "invisible";
    }
  }

  function writePageNumber(pageNumber) {
    window.localStorage.setItem("pageNumber", pageNumber);
  }

  function readPageNumber() {
    const pageNumber = Number(window.localStorage.getItem("pageNumber"));
    if (pageNumber > 1) {
      turnToPage(pageNumber);
    }
  }

  var bookElement;
  var navElement;
  var endElement;
  var scrollTimer;
  var baseFontSize = 18.0;
  var lastMouseDown = Date.now();
  var lastClick = Date.now();

  document.addEventListener("DOMContentLoaded", (e) => {
    bookElement = document.querySelector("div.book");
    navElement = document.querySelector("nav");
    endElement = document.querySelector("p.last-page");

    if (window.location.hash.length > 1) { // > 1, because an empty "#" is length 1
      turnToAnchor(window.location.hash);
    } else {
      readPageNumber();
    }

    // Following a free scroll, this snaps to the nearest page.
    document.body.addEventListener("scroll", (e) => {
      if (scrollTimer) {
        clearTimeout(scrollTimer);
      }

      scrollTimer = setTimeout(() => {
        snapToPage();
      }, 1000);
    });

    // toc button
    document.querySelector("button.toc-button").addEventListener("click", (e) => {
      toggleNav();
      e.stopPropagation();
    });

    // close button
    document.querySelector("div.close-button").addEventListener("click", (e) => {
      toggleNav();
      e.stopPropagation();
    });

    // toc text size buttons
    document.querySelectorAll("nav div.controls button").forEach((button) => {
      const size = `${baseFontSize * button.dataset.scale}px`;
      button.style.fontSize = size;

      button.addEventListener("click", (e) => {
        setTextScale(e.target.dataset.scale);
        e.stopPropagation();
      });
    });

    // this is hacky, but I'm not sure of a better way to wait for
    // style to be applied/computed. The getComputedStyle info isn't yet
    // available when DOMContentLoaded fires.
    setTimeout(function () {
      let realFontSize = Number(
        getComputedStyle(document.documentElement)
          .getPropertyValue("font-size")
          .replace("px", ""),
      );

      document.querySelectorAll("nav div.controls button").forEach((button) => {
        const size = `${realFontSize * button.dataset.scale}px`;
        button.style.fontSize = size;

        button.addEventListener("click", (e) => {
          setTextScale(e.target.dataset.scale);
          e.stopPropagation();
        });
      });
    }, 1000);

    // toc chapter links
    document.querySelectorAll("nav a").forEach((link) => {
      link.addEventListener("click", (e) => {
        toggleNav();
        turnToAnchor(e.target.getAttribute("href"));
        e.stopPropagation();
      });
    });
  });

  document.addEventListener("keydown", (e) => {
    if (event.keyCode === 37) { // left
      e.preventDefault();
      turnPageBack();
    }
    if ((event.keyCode === 39) || (event.keyCode === 32)) { // right, space
      e.preventDefault();
      turnPageForward();
    }
  });

  document.addEventListener("wheel", (e) => {
    if (navElement.className == "visible") {
      return;
    }

    if (Math.abs(e.deltaY) > Math.abs(e.deltaX)) {
      e.preventDefault();
      document.body.scrollLeft += e.deltaY;
    }
  }, { passive: false });

  document.addEventListener("mousedown", function (e) {
    lastMouseDown = Date.now();
  });

  // values in millis
  const CLICK_DEBOUNCE_TIME = 50;
  const LONG_PRESS_TIME = 250;

  document.addEventListener("click", function (e) {
    const now = Date.now();

    // don't advance on long press (text selection?)
    if ((now - lastMouseDown) > LONG_PRESS_TIME) {
      return;
    }

    // don't advance on double-click
    if ((now - lastClick) < CLICK_DEBOUNCE_TIME) {
      return;
    }

    lastClick = now;

    // don't advance on link click
    if (e.target.tagName == "A") {
      return;
    }

    // don't advance if we are selecting text
    if (window.getSelection().toString().length > 0) {
      return;
    }

    // ok... u can advance
    if (e.clientX < (window.innerWidth / 3.0)) {
      turnPageBack();
    } else {
      turnPageForward();
    }
  });

  // hash change detector
  // note: it's a window event, not a document event
  window.addEventListener("hashchange", (e) => {
    if (window.location.hash.length > 1) {
      turnToAnchor(window.location.hash);
    }
  });

  </script>
</head>

<body>

<nav class="invisible">
<div class="controls">
  <button data-scale="0.8">A</button>
  <button data-scale="1.0">A</button>
  <button data-scale="1.2">A</button>
  <button data-scale="1.4">A</button>
  <button data-scale="2.0">A</button>
</div>

<div class="toc">
<h1>Table of Contents</h1>
<div class="close-button">
  <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" x="0px" y="0px" width="100%" height="100%" viewBox="0 0 10 10" xml:space="preserve">
  <g>
    <line x1="0" y1="0" x2="10" y2="10" vector-effect="non-scaling-stroke" />
    <line x1="10" y1="0" x2="0" y2="10" vector-effect="non-scaling-stroke" />
  </g>
</svg>
</div>
{{ web_toc_html }}
</div>
</nav>

<div class="print-cover">
{{ title_html }}
</div>

<div class="book">

<div class="tutorial">
  <h2>How to read</h2>
  <p><i>On a phone:</i><br/>Tap the edges of the page</p>
  <p><i>On a computer:</i><br/>Click the edges of the page, or use the arrow keys, the&nbsp;space&nbsp;bar, the&nbsp;trackpad, or&nbsp;the&nbsp;scroll&nbsp;wheel</p>
  <p><i>On paper:</i></br>Print it out</p>
  <p>Basically, <small>everything works</small></p>
</div>

<img class="cover" src="{{ cover_image }}" alt="" />
{{ title_html }}
{{ web_book_body_html }}
<p class="last-page"></p>

<div class="bookmark">
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" x="0px" y="0px" width="100%" height="100%" viewBox="0 0 40 80" xml:space="preserve">
  <g>
    <polygon points="0,0 0,80 20,70 40,80 40,0"/>
  </g>
</svg>
</div>

</div>

<button class="toc-button">
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" x="0px" y="0px" width="100%" height="100%" viewBox="0 0 80 40" xml:space="preserve">
  <g>
    <rect x="0" y="10" width="5" height="1" />
    <rect x="0" y="20" width="5" height="1" />
    <rect x="0" y="30" width="5" height="1" />

    <rect x="10" y="10" width="70" height="1" />
    <rect x="10" y="20" width="70" height="1" />
    <rect x="10" y="30" width="70" height="1" />
  </g>
</svg>
</button>

</body>
</html>